<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>기술 비교 분석: AGSL-Based vs Record-Based Blur</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Pretendard:wght@300;400;600;700&display=swap');
        
        body {
            font-family: 'Pretendard', sans-serif;
            background-color: #fafaf9;
            color: #44403c;
        }

        .glass-container {
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(231, 229, 228, 0.5);
        }

        .chart-container {
            position: relative;
            width: 100%;
            max-width: 650px;
            margin: 0 auto;
            height: 320px;
            max-height: 400px;
        }

        .comparison-card {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .comparison-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 12px 24px -8px rgba(0, 0, 0, 0.1);
        }

        .dot-grid {
            background-image: radial-gradient(#e7e5e4 1px, transparent 1px);
            background-size: 20px 20px;
        }

        .nav-item.active {
            color: #6366f1;
            font-weight: 700;
            border-bottom: 2px solid #6366f1;
        }

        /* Prevent scroll bar issues on custom canvas */
        canvas {
            display: block;
        }
    </style>
    <!-- Chosen Palette: Warm Stone & Indigo Accent (Stone-50, Indigo-600, Rose-500) -->
    <!-- Application Structure Plan: 
         1. 개요 섹션: Record-Based와 AGSL-Based 기술의 근본적인 접근 차이 설명.
         2. 아키텍처 다이어그램: Canvas 애니메이션을 통해 메모리 복사 vs 픽셀 연산 흐름 시각화.
         3. 성능 분석 대시보드: Chart.js Radar 및 Bar 차트를 이용해 정량적 데이터 비교.
         4. 기술 매트릭스: 지원 사양 및 특징에 대한 상세 비교 테이블.
         5. 의사결정 시나리오: 프로젝트 성격에 따른 적정 기술 선택 가이드라인.
    -->
    <!-- Visualization & Content Choices:
         - Radar Chart: 비디오 적합성, 메모리 효율, 하위 호환성 등 다각도 지표 비교.
         - Bar Chart: 프레임당 발생하는 데이터 전송량 및 오버헤드 시각화.
         - Interactive Canvas: 'Copy' 로직의 병목 현상을 애니메이션으로 표현.
    -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
</head>
<body class="dot-grid min-h-screen">

    <!-- Navbar -->
    <nav class="sticky top-0 z-50 glass-container border-b border-stone-200">
        <div class="max-w-7xl mx-auto px-6 h-16 flex justify-between items-center">
            <div class="text-lg font-bold tracking-tight text-stone-800 flex items-center gap-2">
                <div class="w-3 h-3 bg-indigo-600 rounded-sm rotate-45"></div>
                Backdrop Blur Architecture Analysis
            </div>
            <div class="hidden md:flex space-x-8 text-sm h-full items-center">
                <button onclick="scrollToId('intro')" class="nav-item px-2 py-5 transition hover:text-indigo-600">개요</button>
                <button onclick="scrollToId('architecture')" class="nav-item px-2 py-5 transition hover:text-indigo-600">아키텍처</button>
                <button onclick="scrollToId('analysis')" class="nav-item px-2 py-5 transition hover:text-indigo-600">성능 분석</button>
                <button onclick="scrollToId('matrix')" class="nav-item px-2 py-5 transition hover:text-indigo-600">비교 매트릭스</button>
            </div>
        </div>
    </nav>

    <main class="max-w-5xl mx-auto px-6 py-12">
        
        <!-- Section: Intro -->
        <section id="intro" class="mb-24">
            <div class="mb-2 text-indigo-600 font-bold tracking-widest text-xs uppercase">Comparative Study</div>
            <h1 class="text-4xl md:text-5xl font-extrabold text-stone-900 mb-8 tracking-tight leading-tight">
                블러 구현의 패러다임 비교:<br>
                <span class="text-indigo-600">Record-Based</span> vs <span class="text-indigo-600">AGSL-Based</span>
            </h1>
            <p class="text-xl text-stone-600 leading-relaxed mb-10">
                안드로이드 컴포즈 환경에서 백드롭 블러를 구현하는 두 가지 주요 전략을 분석합니다. 
                배경 이미지를 <strong>기록 및 복사(Record-Based)</strong>하는 방식과, 
                GPU 셰이더를 통해 <strong>실시간 마스킹(AGSL-Based)</strong>을 수행하는 방식의 성능 편차를 데이터로 확인하십시오.
            </p>
            
            <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                <div class="glass-container rounded-3xl p-8 border-t-4 border-t-stone-300">
                    <div class="flex items-center gap-3 mb-4">
                        <div class="w-8 h-8 rounded-full bg-stone-100 flex items-center justify-center font-bold text-stone-500">R</div>
                        <h3 class="font-bold text-xl text-stone-800">Record-Based</h3>
                    </div>
                    <p class="text-stone-600 leading-relaxed">
                        배경 콘텐츠를 GraphicsLayer에 캡처한 뒤, 이를 축소하여 블러 처리를 수행하고 다시 그리는 방식입니다. 
                        안드로이드 12(API 31)부터 지원되며, 범용성이 높으나 비디오와 같은 고부하 콘텐츠에서 메모리 복사 비용이 발생합니다.
                    </p>
                </div>
                <div class="glass-container rounded-3xl p-8 border-t-4 border-t-indigo-600">
                    <div class="flex items-center gap-3 mb-4">
                        <div class="w-8 h-8 rounded-full bg-indigo-100 flex items-center justify-center font-bold text-indigo-600">A</div>
                        <h3 class="font-bold text-xl text-indigo-900">AGSL-Based</h3>
                    </div>
                    <p class="text-stone-600 leading-relaxed">
                        안드로이드 13(API 33) 이상의 셰이더 기능을 활용합니다. 
                        배경을 복사하지 않고 렌더링 단계에서 픽셀 위치를 직접 계산하여 블러를 적용하는 <strong>Zero-copy</strong> 방식입니다. 
                        동적 비디오 배경에 최적화된 고성능 솔루션입니다.
                    </p>
                </div>
            </div>
        </section>

        <!-- Section: Architecture Map -->
        <section id="architecture" class="mb-24">
            <div class="flex items-center justify-between mb-8">
                <h2 class="text-3xl font-bold text-stone-900 tracking-tight">아키텍처 렌더링 파이프라인</h2>
                <div class="flex gap-4">
                    <div class="flex items-center gap-2 text-xs font-medium text-stone-500">
                        <span class="w-3 h-3 bg-rose-400 rounded-full"></span> Record-Based (Copy)
                    </div>
                    <div class="flex items-center gap-2 text-xs font-medium text-stone-500">
                        <span class="w-3 h-3 bg-indigo-400 rounded-full"></span> AGSL-Based (Direct)
                    </div>
                </div>
            </div>
            
            <div class="glass-container rounded-[2rem] p-10 overflow-hidden relative border-dashed border-2 border-stone-200">
                <div class="flex flex-col lg:flex-row gap-12 items-center">
                    <div class="w-full lg:w-2/5">
                        <div class="space-y-6">
                            <div>
                                <h4 class="font-bold text-stone-800 mb-2">메모리 흐름 제어</h4>
                                <p class="text-sm text-stone-600 leading-relaxed">
                                    오른쪽 캔버스는 데이터 전송 방식을 시각화합니다. 
                                    상단의 붉은 점선은 복사본을 생성하는 'Record' 기법의 메모리 부하를 나타내며, 
                                    하단의 푸른 실선은 AGSL의 다이렉트 접근을 나타냅니다.
                                </p>
                            </div>
                            <div class="p-4 bg-stone-50 rounded-xl border border-stone-200">
                                <h5 class="text-xs font-bold text-stone-400 uppercase mb-2">Key Takeaway</h5>
                                <p class="text-xs text-stone-600">Record-Based는 복사 과정에서 CPU/GPU 버스 대역폭을 소모하지만, AGSL-Based는 동일 드로우 콜 내에서 연산이 완결됩니다.</p>
                            </div>
                        </div>
                    </div>
                    <div class="w-full lg:w-3/5 flex justify-center">
                        <canvas id="archCanvas" class="w-full h-72 bg-white rounded-2xl shadow-inner border border-stone-100"></canvas>
                    </div>
                </div>
            </div>
        </section>

        <!-- Section: Performance Dashboard -->
        <section id="analysis" class="mb-24">
            <h2 class="text-3xl font-bold text-stone-900 mb-10 tracking-tight">정량적 성능 대시보드</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-12">
                
                <div class="bg-white rounded-[2rem] p-10 shadow-sm border border-stone-200 flex flex-col items-center">
                    <h3 class="text-lg font-bold mb-6 text-stone-800">기술 성능 스코어 (Radar)</h3>
                    <div class="chart-container">
                        <canvas id="radarChart"></canvas>
                    </div>
                    <div class="mt-8 text-xs text-stone-500 leading-relaxed px-4 text-center">
                        AGSL-Based는 비디오 적합성과 메모리 효율에서 만점에 가까운 점수를 기록합니다. 
                        반면 Record-Based는 광범위한 버전 지원이 큰 강점입니다.
                    </div>
                </div>

                <div class="bg-white rounded-[2rem] p-10 shadow-sm border border-stone-200 flex flex-col items-center">
                    <h3 class="text-lg font-bold mb-6 text-stone-800">프레임당 부하 비교 (Relative)</h3>
                    <div class="chart-container">
                        <canvas id="barChart"></canvas>
                    </div>
                    <div class="mt-8 text-xs text-stone-500 leading-relaxed px-4 text-center">
                        Record-Based는 데이터 복사로 인해 FHD 환경에서 초당 수백 MB의 전송량이 발생할 수 있습니다. 
                        AGSL-Based는 이를 0에 가깝게 유지합니다.
                    </div>
                </div>

            </div>
        </section>

        <!-- Section: Comparison Matrix -->
        <section id="matrix" class="mb-24">
            <h2 class="text-3xl font-bold text-stone-900 mb-8 tracking-tight">기술 사양 상세 매트릭스</h2>
            <div class="overflow-x-auto glass-container rounded-[2rem] shadow-sm border-none">
                <table class="w-full text-sm text-left border-collapse">
                    <thead class="bg-stone-50 text-stone-500 font-bold uppercase text-xs">
                        <tr>
                            <th class="px-8 py-6 border-b border-stone-100">비교 지표</th>
                            <th class="px-8 py-6 border-b border-stone-100">Record-Based</th>
                            <th class="px-8 py-6 border-b border-stone-100 text-indigo-600 bg-indigo-50/30">AGSL-Based</th>
                        </tr>
                    </thead>
                    <tbody class="divide-y divide-stone-100">
                        <tr class="hover:bg-stone-50/50 transition">
                            <td class="px-8 py-6 font-bold text-stone-800">최소 OS 지원</td>
                            <td class="px-8 py-6">Android 12 (API 31)</td>
                            <td class="px-8 py-6 text-indigo-700 font-semibold bg-indigo-50/10">Android 13 (API 33)</td>
                        </tr>
                        <tr class="hover:bg-stone-50/50 transition">
                            <td class="px-8 py-6 font-bold text-stone-800">데이터 전송 방식</td>
                            <td class="px-8 py-6">Buffer Copy & Scaling</td>
                            <td class="px-8 py-6 text-indigo-700 font-semibold bg-indigo-50/10">Direct GPU Access</td>
                        </tr>
                        <tr class="hover:bg-stone-50/50 transition">
                            <td class="px-8 py-6 font-bold text-stone-800">비디오 스트리밍</td>
                            <td class="px-8 py-6">오버헤드 발생 (Record Call)</td>
                            <td class="px-8 py-6 text-indigo-700 font-semibold bg-indigo-50/10">최적화됨 (Zero-copy)</td>
                        </tr>
                        <tr class="hover:bg-stone-50/50 transition">
                            <td class="px-8 py-6 font-bold text-stone-800">다중 마스크 영역</td>
                            <td class="px-8 py-6">개별 레이어 캡처 필요</td>
                            <td class="px-8 py-6 text-indigo-700 font-semibold bg-indigo-50/10">단일 셰이더 내 다중 처리</td>
                        </tr>
                        <tr class="hover:bg-stone-50/50 transition">
                            <td class="px-8 py-6 font-bold text-stone-800">화질 보정 기술</td>
                            <td class="px-8 py-6">기본 블러 (Scaling 의존)</td>
                            <td class="px-8 py-6 text-indigo-700 font-semibold bg-indigo-50/10">결정론적 지터링 적용</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </section>

        <!-- Section: Decision Guide -->
        <section class="mb-32">
            <h2 class="text-3xl font-bold text-stone-900 mb-10 text-center">프로젝트 상황별 기술 선택 가이드</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-10">
                <div class="p-10 bg-stone-100 rounded-[2.5rem] border border-stone-200 relative overflow-hidden group">
                    <div class="absolute -top-12 -right-12 w-32 h-32 bg-stone-200 rounded-full opacity-50 group-hover:scale-110 transition-transform duration-700"></div>
                    <h3 class="font-bold text-2xl text-stone-800 mb-6 flex items-center gap-3">
                        <span class="w-10 h-10 rounded-xl bg-white flex items-center justify-center text-sm shadow-sm">1</span>
                        Record-Based 추천
                    </h3>
                    <ul class="space-y-4 text-stone-600">
                        <li class="flex items-start gap-3">
                            <span class="mt-1.5 w-1.5 h-1.5 bg-stone-400 rounded-full flex-shrink-0"></span>
                            안드로이드 12(API 31) 사용자를 포함해야 하는 범용 서비스
                        </li>
                        <li class="flex items-start gap-3">
                            <span class="mt-1.5 w-1.5 h-1.5 bg-stone-400 rounded-full flex-shrink-0"></span>
                            배경이 변하지 않는 정적 이미지나 복잡하지 않은 UI 배경
                        </li>
                        <li class="flex items-start gap-3">
                            <span class="mt-1.5 w-1.5 h-1.5 bg-stone-400 rounded-full flex-shrink-0"></span>
                            셰이더 코드 유지보수 인력이 부족한 경우
                        </li>
                    </ul>
                </div>
                <div class="p-10 bg-indigo-600 rounded-[2.5rem] shadow-xl relative overflow-hidden group">
                    <div class="absolute -top-12 -right-12 w-32 h-32 bg-indigo-500 rounded-full opacity-30 group-hover:scale-110 transition-transform duration-700"></div>
                    <h3 class="font-bold text-2xl text-white mb-6 flex items-center gap-3">
                        <span class="w-10 h-10 rounded-xl bg-indigo-500 flex items-center justify-center text-sm text-white shadow-sm">2</span>
                        AGSL-Based 추천
                    </h3>
                    <ul class="space-y-4 text-indigo-100">
                        <li class="flex items-start gap-3">
                            <span class="mt-1.5 w-1.5 h-1.5 bg-indigo-300 rounded-full flex-shrink-0"></span>
                            비디오 재생, 고주사율 애니메이션 등 동적 배경 중심의 서비스
                        </li>
                        <li class="flex items-start gap-3">
                            <span class="mt-1.5 w-1.5 h-1.5 bg-indigo-300 rounded-full flex-shrink-0"></span>
                            고사양(API 33+) 기기를 주 타겟으로 하는 프리미엄 앱
                        </li>
                        <li class="flex items-start gap-3">
                            <span class="mt-1.5 w-1.5 h-1.5 bg-indigo-300 rounded-full flex-shrink-0"></span>
                            메모리 점유율을 극한으로 낮춰야 하는 시스템 최적화 프로젝트
                        </li>
                    </ul>
                </div>
            </div>
        </section>

    </main>

    <footer class="bg-stone-900 py-20 px-6 text-center text-stone-500">
        <div class="max-w-5xl mx-auto">
            <div class="mb-8 flex justify-center gap-4">
                <div class="w-2 h-2 rounded-full bg-stone-700"></div>
                <div class="w-2 h-2 rounded-full bg-stone-700"></div>
                <div class="w-2 h-2 rounded-full bg-stone-700"></div>
            </div>
            <p class="text-sm mb-4 font-bold tracking-widest uppercase">Technical Insight Report: Architecture Comparison</p>
            <p class="text-xs opacity-50 max-w-lg mx-auto leading-relaxed">
                본 리포트는 Jetpack Compose 환경에서 최적의 그래픽 성능을 도출하기 위한 아키텍처 연구의 결과물입니다. 
                제시된 수치는 FHD 해상도 환경을 기준으로 한 기술적 예상치입니다.
            </p>
        </div>
    </footer>

    <script>
        // Smooth scrolling for navigation
        function scrollToId(id) {
            const el = document.getElementById(id);
            const offset = 80;
            const bodyRect = document.body.getBoundingClientRect().top;
            const elementRect = el.getBoundingClientRect().top;
            const elementPosition = elementRect - bodyRect;
            const offsetPosition = elementPosition - offset;

            window.scrollTo({
                top: offsetPosition,
                behavior: 'smooth'
            });

            // Update active state
            document.querySelectorAll('.nav-item').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
        }

        window.onload = function() {
            // Radar Chart Initialization
            const radarCtx = document.getElementById('radarChart').getContext('2d');
            new Chart(radarCtx, {
                type: 'radar',
                data: {
                    labels: ['비디오 적합성', '메모리 효율', '구현 용이성', '실시간성', '하위 호환성'],
                    datasets: [{
                        label: 'AGSL-Based',
                        data: [100, 100, 55, 100, 20],
                        backgroundColor: 'rgba(99, 102, 241, 0.2)',
                        borderColor: '#6366f1',
                        borderWidth: 3,
                        pointBackgroundColor: '#6366f1',
                        pointHoverRadius: 5
                    }, {
                        label: 'Record-Based',
                        data: [45, 50, 95, 65, 100],
                        backgroundColor: 'rgba(168, 162, 158, 0.2)',
                        borderColor: '#a8a29e',
                        borderWidth: 2,
                        pointBackgroundColor: '#a8a29e',
                        pointHoverRadius: 5
                    }]
                },
                options: {
                    maintainAspectRatio: false,
                    scales: {
                        r: {
                            beginAtZero: true,
                            max: 100,
                            ticks: { display: false },
                            grid: { color: 'rgba(0,0,0,0.05)' },
                            angleLines: { color: 'rgba(0,0,0,0.05)' },
                            pointLabels: { font: { size: 10, weight: '600' } }
                        }
                    },
                    plugins: {
                        legend: { position: 'bottom', labels: { boxWidth: 12, padding: 20, font: { size: 11 } } }
                    }
                }
            });

            // Bar Chart Initialization
            const barCtx = document.getElementById('barChart').getContext('2d');
            new Chart(barCtx, {
                type: 'bar',
                data: {
                    labels: ['메모리 전송량 (MB/s)', 'CPU 점유율 (%)'],
                    datasets: [{
                        label: 'Record-Based',
                        data: [420, 18],
                        backgroundColor: '#a8a29e',
                        borderRadius: 6
                    }, {
                        label: 'AGSL-Based',
                        data: [5, 2],
                        backgroundColor: '#6366f1',
                        borderRadius: 6
                    }]
                },
                options: {
                    maintainAspectRatio: false,
                    scales: {
                        y: { 
                            beginAtZero: true,
                            grid: { display: false },
                            ticks: { font: { size: 10 } }
                        },
                        x: {
                            grid: { display: false },
                            ticks: { font: { size: 10, weight: '600' } }
                        }
                    },
                    plugins: {
                        legend: { position: 'bottom', labels: { boxWidth: 12, padding: 20, font: { size: 11 } } }
                    }
                }
            });

            // Architecture Animation Logic
            const archCanvas = document.getElementById('archCanvas');
            const ctx = archCanvas.getContext('2d');
            let frame = 0;

            function drawArchitecture() {
                const w = archCanvas.width = archCanvas.parentElement.clientWidth;
                const h = archCanvas.height = 288;
                ctx.clearRect(0, 0, w, h);

                const sourceX = w * 0.25;
                const effectX = w * 0.75;
                const centerY = h * 0.5;

                // Title Labels
                ctx.fillStyle = '#a8a29e';
                ctx.font = 'bold 10px Inter';
                ctx.textAlign = 'center';
                ctx.fillText('SOURCE (BACKGROUND)', sourceX, centerY - 55);
                ctx.fillText('EFFECT (BLUR)', effectX, centerY - 55);

                // Source Module
                ctx.fillStyle = '#f5f5f4';
                ctx.beginPath();
                ctx.roundRect(sourceX - 35, centerY - 35, 70, 70, 12);
                ctx.fill();
                ctx.strokeStyle = '#e7e5e4';
                ctx.stroke();
                ctx.fillStyle = '#d6d3d1';
                ctx.font = 'bold 14px Inter';
                ctx.fillText('BG', sourceX, centerY + 6);

                // Effect Module
                ctx.fillStyle = '#6366f1';
                ctx.beginPath();
                ctx.roundRect(effectX - 35, centerY - 35, 70, 70, 12);
                ctx.fill();
                ctx.fillStyle = '#ffffff';
                ctx.fillText('BLUR', effectX, centerY + 6);

                // Path 1: Record-Based (Copy Arch)
                ctx.setLineDash([4, 4]);
                ctx.strokeStyle = '#fda4af';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(sourceX + 35, centerY - 15);
                ctx.quadraticCurveTo(w * 0.5, centerY - 100, effectX - 35, centerY - 15);
                ctx.stroke();

                // Animated Particle for Record-Based
                const recordPos = (frame % 100) / 100;
                const rx = sourceX + 35 + (effectX - sourceX - 70) * recordPos;
                const ry = centerY - 15 - Math.sin(recordPos * Math.PI) * 55;
                ctx.fillStyle = '#fb7185';
                ctx.beginPath();
                ctx.arc(rx, ry, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#fb7185';
                ctx.font = 'bold 10px Inter';
                ctx.fillText('Buffer Copy', w * 0.5, centerY - 95);

                // Path 2: AGSL-Based (Direct Access)
                ctx.setLineDash([]);
                ctx.strokeStyle = '#818cf8';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(sourceX + 35, centerY + 15);
                ctx.quadraticCurveTo(w * 0.5, centerY + 100, effectX - 35, centerY + 15);
                ctx.stroke();

                // Animated Particle for AGSL-Based
                const agslPos = (frame % 80) / 80;
                const ax = sourceX + 35 + (effectX - sourceX - 70) * agslPos;
                const ay = centerY + 15 + Math.sin(agslPos * Math.PI) * 60;
                ctx.fillStyle = '#4f46e5';
                ctx.beginPath();
                ctx.arc(ax, ay, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#4f46e5';
                ctx.fillText('Direct Shader Access', w * 0.5, centerY + 110);

                frame++;
                requestAnimationFrame(drawArchitecture);
            }

            // Redraw on window resize
            window.addEventListener('resize', () => {
                drawArchitecture();
            });

            drawArchitecture();
        };
    </script>
</body>
</html>
